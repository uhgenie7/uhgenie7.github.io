<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://uhgenie7.github.io/blog</id>
    <title>Genie's Dev Blog Blog</title>
    <updated>2022-10-12T00:00:00.000Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://uhgenie7.github.io/blog"/>
    <subtitle>Genie's Dev Blog Blog</subtitle>
    <icon>https://uhgenie7.github.io/img/favicon.ico</icon>
    <entry>
        <title type="html"><![CDATA[Stale While Revalidate]]></title>
        <id>/stale-while-revalidate/stale-while-revalidate</id>
        <link href="https://uhgenie7.github.io/blog/stale-while-revalidate/stale-while-revalidate"/>
        <updated>2022-10-12T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[stale-while-revalidate 이란?]]></summary>
        <content type="html"><![CDATA[<h2 class="anchor anchorWithStickyNavbar_LWe7" id="stale-while-revalidate">stale-while-revalidate?<a class="hash-link" href="#stale-while-revalidate" title="제목으로 바로 가기">​</a></h2><blockquote><p><strong>The stale-while-revalidate Cache-Control Extension</strong><br>
<!-- -->When present in an HTTP response, the stale-while-revalidate Cache-Control extension indicates that caches MAY serve the response in which it appears after it becomes stale, up to the indicated number of seconds.</p></blockquote><blockquote><p>캐시된 응답이 오래된 것일 수 있다는 아이디어와 재검증 프로세스.</p></blockquote><p>캐시란 자주 쓰이는 문서의 사본을 자동으로 보관하는 HTTP 장치다. 웹 요청이 캐시에 도착했을 때, 캐시된 로컬 사본이 존재한다면, 그 문서는 원서버가 아니라 캐시로부터 제공된다. 즉, 캐시된 콘텐츠를 즉시 로드하는 <strong>즉시성</strong>을 가지고 있다.</p><p>요즘 자주 들어가는 사이트인 <code>docusaurus</code>에 다시 들어가 보았다. 이곳의 Network를 확인해보자 이미지 외 다수가 (memory cache) 되어있고 즉시 가져온 것을 확인할 수 있었다.</p><p><img loading="lazy" alt="0ms로 가져온 모습" src="/assets/images/cashe1-4615d6ab67a0a543eb38f8ca89b79af2.png" width="971" height="312" class="img_ev3q">
<em>0ms로 가져온 모습</em></p><p>오랜 시간 뒤, 이 웹 사이트를 다시 들어가본다고 하자. 그 사이에 docusaurus 사이트에서 문서를 업데이트 했다고 생각해보자. 그럼에도 브라우저가 오래된 캐시를 계속 가져온다면 우리는 오래된 문서를 볼 수밖에 없다. 오래된 것을 stale 하다고 이야기한다.</p><p>이처럼 원 서버 컨텐츠는 변경될 수 있기 때문에, 캐시는 반드시 그들이 갖고 있는 사본이 여전히 최신인지 서버를 통해 점검해야한다.</p><p>stale-while-revalidate는 캐시된 콘텐츠에 대한 업데이트가 향후에 사용되도록 보장하는 최신성 간의 균형을 유지하는 데 도움이 된다.</p><p><img loading="lazy" alt="Cache-Control을 확인해보자" src="/assets/images/cashe3-186a1fbcf737a1dd28148db716db92ec.png" width="903" height="348" class="img_ev3q"></p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="메커니즘">메커니즘<a class="hash-link" href="#메커니즘" title="제목으로 바로 가기">​</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="오래-되었다는-기준은">'오래 되었다'는 기준은?<a class="hash-link" href="#오래-되었다는-기준은" title="제목으로 바로 가기">​</a></h3><ol><li>요청이 처음 전송되면 브라우저에 의해 캐시된다.</li><li>동일한 요청이 두 번째로 전송되면 캐시를 먼저 확인한다.</li><li>해당 요청의 캐시가 <strong>사용 가능</strong>하고 <strong>유효</strong>한 경우 캐시가 응답으로 반환한다.</li><li>그런 다음 캐시에 staleness(<!-- -->*<!-- -->오래된)가 있는지 확인하고 staleness가 발견되면 업데이트된다.<ul><li>여기서 캐시의 staleness는 <code>Cache-Control Header</code>에 있는 <code>max-age</code>값과 <code>stale-while-revalidate</code>에 의해 결정된다.</li><li>max-age가 만료되지 않았다<ul><li>아무것도 하지 않음</li></ul></li><li>max-age가 만료되었다.<ul><li><code>stale-while-revalidate</code> 확인,</li><li><code>stale-while-revalidate</code> 가 만료되지 않았다면?</li><li>캐시된 응답의 사용을 지연시키지 않는 방식으로 네트워크에 대해 "재검증" 요청이 이루어진다. 반환된 응답은 이전에 캐시된 응답과 동일한 정보를 포함하거나 다를 수 있다.</li><li>어느 쪽이든 네트워크 응답은 로컬에 저장되어 이전에 캐시된 항목을 대체하고 향후 max-age 비교 중에 사용되는 "최신성" 타이머를 재설정한다.</li></ul></li><li><code>stale-while-revalidate</code>마저 넘었다면<ul><li>데이터를 새로 요청한다.</li></ul></li></ul></li></ol><p><img loading="lazy" alt="매커니즘" src="/assets/images/cashe2-073f2cd2df04eb2885deba37fa3db371.png" width="1720" height="1189" class="img_ev3q">
<em>출처:toptal</em></p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="server-state와-ui-state의-차이">Server State와 UI State의 차이<a class="hash-link" href="#server-state와-ui-state의-차이" title="제목으로 바로 가기">​</a></h2><p>이에 대해선 <code>tanstack-query</code>라이브러리가 잘 설명해주고 있다. 서버 상태 라이브러리 중 하나인 <code>tanstack-query</code>는 이처럼 이야기한다.</p><blockquote><p>React Query는 서버와 클라이언트 간의 비동기 작업을 관리 하는 서버 상태 라이브러리입니다.
Redux, MobX, Zusstand 등은 비동기 데이터를 저장하는 데 사용할 수 있는 클라이언트 상태 라이브러리 이지만 React Query와 같은 도구와 비교할 때 비효율적입니다.</p></blockquote><p>다음과 같은 전역 상태가 있다고 해보자.</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">const globalState = {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  projects,</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  teams,</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  tasks,</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  users,</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  themeMode,</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  sidebarStatus,</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="클립보드에 코드 복사" title="복사" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>이를 '서버 상태'와 'UI 상태'로 나누어보자면 다음과 같다.</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">const serverState = {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  projects,</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  teams,</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  tasks,</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  users</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="클립보드에 코드 복사" title="복사" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">const uiState = {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  themeMode,</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  sidebarStatus,</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="클립보드에 코드 복사" title="복사" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>서버에서 가져오는 데이터를 캐싱할 수 있는 <code>projects</code>, <code>teams</code>, <code>tasks</code>, <code>users</code> 상태는 언제든지 stale 해질 수 있지만, 다크모드 같은 스타일이나 사이드바의 여닫힘은 그렇지 않다.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="reference">Reference<a class="hash-link" href="#reference" title="제목으로 바로 가기">​</a></h2><ul><li><a href="https://www.rfc-editor.org/rfc/rfc5861#section-3" target="_blank" rel="noopener noreferrer">rfc</a></li><li><a href="https://web.dev/stale-while-revalidate/" target="_blank" rel="noopener noreferrer">web.dev</a></li><li><a href="https://www.toptal.com/react-hooks/stale-while-revalidate" target="_blank" rel="noopener noreferrer">toptal</a></li><li><a href="https://tanstack.com/query/v4/docs/guides/does-this-replace-client-state?from=reactQueryV3&amp;original=https://react-query-v3.tanstack.com/guides/does-this-replace-client-state" target="_blank" rel="noopener noreferrer">tanstack</a></li><li><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control" target="_blank" rel="noopener noreferrer">mdn</a></li></ul>]]></content>
        <category label="stale-while-revalidate" term="stale-while-revalidate"/>
        <category label="cache" term="cache"/>
    </entry>
</feed>